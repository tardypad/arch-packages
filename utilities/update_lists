#!/usr/bin/env zsh

COMMAND=${0:t}


usage() {
  cat << EOF
usage: ${COMMAND} [<options>]

Update lists of explicitely installed packages per repository
ignoring the base system packages

Needs to be run from the repository root

Options:
  -h,  --help    show this message only
EOF
}


error() {
  [[ -z "$1" ]] || echo "${COMMAND}: $1" >&2
  echo "Try '${COMMAND} --help' for more information." >&2
  exit 1
}


update_lists() {
  # ignore base packages
  local ignore_packages=$(
    pacman --query --quiet --groups base base-devel
  )

  # ignore system packages installed during installation
  ignore_packages+='
efibootmgr
grub
intel-ucode
os-prober
'

  local explicit_packages=$(
    pacman --query --quiet --explicit
  )

  for repo in $( pacconf --repo-list ); do
    local repo_packages_file="lists/${repo}"

    local repo_packages=$(
      comm -12 \
        <( echo "${explicit_packages}" | sort ) \
        <( paclist "${repo}" | cut --field 1 --delimiter ' ' | sort )
    )

    local filtered_repo_packages=$(
      comm -23 \
        <( echo "${repo_packages}" | sort ) \
        <( echo "${ignore_packages}" | sort )
     )

    local final_repo_packages=
    if [[ ! -f "${repo_packages_file}" ]]; then
      final_repo_packages="${filtered_repo_packages}"
    else
      local tmp_file=$( mktemp )
      echo "${filtered_repo_packages}" > "${tmp_file}"
      final_repo_packages=$(
        merge_packages_files "${repo_packages_file}" "${tmp_file}"
      )
      rm "${tmp_file}"
    fi

    echo "${final_repo_packages}" > "${repo_packages_file}"
  done
}


merge_packages_files() {
  # old file contains the packages list with comments to keep
  local old_packages_file="$1"
  local new_packages_file="$2"

  local common_packages=$(
    comm -12 \
      <( cut --field 1 --delimiter ' ' "${old_packages_file}" ) \
      "${new_packages_file}"
  )

  local new_packages=$(
    comm -13 \
      <( cut --field 1 --delimiter ' ' "${old_packages_file}" ) \
      "${new_packages_file}"
  )

  {
    echo "${common_packages}" \
      | while read common_package; do
        grep --extended-regexp "^${common_package}( |$)" "${old_packages_file}"
        done;
    echo "${new_packages}";
  } \
    | grep --invert-match '^$' \
    | sort --key 1,1
}


parse_options() {
  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      -h|--help)
        usage
        exit 0
        ;;
      *)
        error "Invalid option '$1'"
        ;;
    esac
  done
}


parse_options "$@"

update_lists
